<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
  <title>跃马迎春 · 15秒冲分</title>
  <style>
    :root {
      --bg-top: #0e2a40;
      --bg-mid: #173e57;
      --bg-bot: #fce8c8;
      --red: #c9222d;
      --gold: #f3c044;
      --ink: #1f1a17;
      --paper: #fff7e8;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      touch-action: manipulation;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Trebuchet MS", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background: radial-gradient(circle at 50% 15%, #2c5b76 0%, #14314a 48%, #081723 100%);
      color: var(--paper);
    }

    #app {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      padding: max(env(safe-area-inset-top), 8px) max(env(safe-area-inset-right), 8px) max(env(safe-area-inset-bottom), 8px) max(env(safe-area-inset-left), 8px);
    }

    .stage-wrap {
      position: relative;
      width: min(100vw - 16px, calc((100vh - 16px) * 0.58));
      height: min(100vh - 16px, calc((100vw - 16px) * 1.72));
      border-radius: 20px;
      overflow: hidden;
      border: 2px solid #f5d28a;
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.45);
      background: linear-gradient(180deg, var(--bg-top) 0%, var(--bg-mid) 56%, var(--bg-bot) 100%);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
    }

    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.45);
    }

    .pill {
      background: rgba(201, 34, 45, 0.82);
      border: 1px solid rgba(255, 232, 170, 0.65);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 13px;
      letter-spacing: 0.3px;
    }

    .combo {
      margin-top: 6px;
      font-size: 12px;
      color: #ffef9f;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: linear-gradient(180deg, rgba(20, 10, 6, 0.16) 0%, rgba(20, 10, 6, 0.5) 100%);
      text-align: center;
      padding: 22px;
    }

    .card {
      width: min(92%, 350px);
      background: linear-gradient(180deg, rgba(255, 247, 232, 0.96) 0%, rgba(255, 234, 191, 0.95) 100%);
      color: var(--ink);
      border-radius: 20px;
      border: 2px solid #c89535;
      padding: 18px 14px 16px;
      box-shadow: 0 16px 34px rgba(0, 0, 0, 0.35);
    }

    .title {
      margin: 2px 0 8px;
      color: var(--red);
      font-size: 27px;
      line-height: 1.05;
      letter-spacing: 1px;
    }

    .subtitle {
      margin: 0 0 12px;
      font-size: 13px;
      color: #5d2d1d;
      line-height: 1.45;
    }

    .stats {
      text-align: left;
      background: rgba(255, 255, 255, 0.58);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 12px;
      font-size: 14px;
      line-height: 1.5;
    }

    .result-card .title {
      font-size: 30px;
      letter-spacing: 2px;
      margin-bottom: 12px;
      color: #b81f26;
    }

    .result-card .stats {
      text-align: center;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.72) 0%, rgba(255, 248, 220, 0.7) 100%);
      border: 1px solid rgba(200, 149, 53, 0.45);
      padding: 12px;
      line-height: 1.62;
      margin-bottom: 4px;
    }

    button {
      width: 100%;
      border: 0;
      border-radius: 999px;
      padding: 12px 14px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.14s ease, filter 0.18s ease;
      margin-top: 8px;
    }

    button:active {
      transform: scale(0.98);
    }

    .primary {
      background: linear-gradient(180deg, #df2e37 0%, #bc2029 100%);
      color: #fff8ea;
    }

    .secondary {
      background: linear-gradient(180deg, #f8cb5b 0%, #e9aa2e 100%);
      color: #4f250f;
    }

    .tip {
      margin-top: 10px;
      font-size: 12px;
      color: #6f3d22;
      line-height: 1.4;
    }

    .hidden {
      display: none;
    }

    .landscape-tip {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(5, 10, 16, 0.92);
      color: #fff3d4;
      text-align: center;
      padding: 20px;
      font-size: 18px;
      z-index: 99;
    }

    @media (orientation: landscape) and (max-height: 580px) {
      .landscape-tip {
        display: grid;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="stage-wrap">
      <canvas id="game" width="540" height="930" aria-label="跃马迎春游戏画面"></canvas>
      <div class="hud">
        <div>
          <div class="pill" id="timeText">30.0秒</div>
          <div class="combo" id="comboText">连击 x1</div>
        </div>
        <div class="pill" id="scoreText">0 分</div>
      </div>

      <div class="overlay" id="startOverlay">
        <div class="card">
          <h1 class="title">跃马迎春</h1>
          <p class="subtitle">15秒竖屏自动跑酷<br>点击跳跃，空中再点二段跳</p>
          <button class="primary" id="startBtn">开始冲分</button>
          <p class="tip">踩年兽、收元宝、吃福字和年糕，15秒后自动结算</p>
        </div>
      </div>

      <div class="overlay hidden" id="resultOverlay">
        <div class="card result-card">
          <h2 class="title" id="resultTitle">称号</h2>
          <div class="stats" id="resultStats"></div>
          <button class="primary" id="retryBtn">再来一局（15秒）</button>
        </div>
      </div>
    </div>
  </div>

  <div class="landscape-tip">请竖屏游玩<br>Rotate to Portrait</div>

  <script>
    (function () {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const timeText = document.getElementById("timeText");
      const comboText = document.getElementById("comboText");
      const scoreText = document.getElementById("scoreText");
      const startOverlay = document.getElementById("startOverlay");
      const resultOverlay = document.getElementById("resultOverlay");
      const resultTitle = document.getElementById("resultTitle");
      const resultStats = document.getElementById("resultStats");

      const startBtn = document.getElementById("startBtn");
      const retryBtn = document.getElementById("retryBtn");

      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;
      const GROUND_Y = HEIGHT - 135;

      const state = {
        mode: "ready",
        timeLeft: 15,
        elapsed: 0,
        score: 0,
        combo: 1,
        maxCombo: 1,
        coins: 0,
        stompCount: 0,
        distance: 0,
        speed: 340,
        flashHit: 0,
        particles: [],
        soundsReady: false
      };

      const player = {
        x: 155,
        y: GROUND_Y - 82,
        w: 78,
        h: 82,
        vx: 0,
        vy: 0,
        onGround: true,
        jumpsUsed: 0,
        invincible: 0,
        speedBuff: 0
      };

      const world = {
        segments: [],
        enemies: [],
        pickups: [],
        hazards: [],
        totalLength: 0
      };

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function randInt(min, max) {
        return Math.floor(rand(min, max + 1));
      }

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function resetGame() {
        state.mode = "playing";
        state.timeLeft = 15;
        state.elapsed = 0;
        state.score = 0;
        state.combo = 1;
        state.maxCombo = 1;
        state.coins = 0;
        state.stompCount = 0;
        state.distance = 0;
        state.speed = 340;
        state.flashHit = 0;
        state.particles = [];

        player.x = 155;
        player.y = GROUND_Y - player.h;
        player.vx = 0;
        player.vy = 0;
        player.onGround = true;
        player.jumpsUsed = 0;
        player.invincible = 0;
        player.speedBuff = 0;

        world.segments = [];
        world.enemies = [];
        world.pickups = [];
        world.hazards = [];
        world.totalLength = 0;

        buildInitialSegments();
        updateHud();
      }

      function buildInitialSegments() {
        for (let i = 0; i < 8; i += 1) addSegment();
      }

      function addSegment() {
        const start = world.totalLength;
        const segWidth = randInt(190, 310);
        const lane = randInt(0, 3);
        const yBias = lane === 0 ? 0 : lane === 1 ? -45 : lane === 2 ? -82 : -120;
        const blockY = GROUND_Y + yBias;
        world.segments.push({ x: start, y: blockY, w: segWidth, h: 24 });

        if (Math.random() < 0.25) {
          const gapX = start + segWidth + randInt(22, 48);
          const gapW = randInt(56, 100);
          world.hazards.push({ x: gapX, y: GROUND_Y + 24, w: gapW, h: 120 });
          world.totalLength = gapX + gapW;
        } else {
          world.totalLength = start + segWidth + randInt(42, 78);
        }

        if (Math.random() < 0.5) {
          world.pickups.push(makePickup(start + segWidth * rand(0.2, 0.82), blockY - 46, "coin"));
        }
        if (Math.random() < 0.18) {
          world.pickups.push(makePickup(start + segWidth * rand(0.3, 0.82), blockY - 52, "fu"));
        }
        if (Math.random() < 0.14) {
          world.pickups.push(makePickup(start + segWidth * rand(0.24, 0.74), blockY - 52, "cake"));
        }
        if (Math.random() < 0.35) {
          world.enemies.push(makeEnemy(start + segWidth * rand(0.35, 0.9), blockY - 42));
        }
      }

      function makeEnemy(x, y) {
        return { x, y, w: 52, h: 42, vx: rand(42, 86), dead: false };
      }

      function makePickup(x, y, type) {
        return { x, y, w: 36, h: 36, type, dead: false, bob: rand(0, Math.PI * 2) };
      }

      function jump() {
        if (state.mode !== "playing") return;
        if (player.onGround) {
          player.vy = -550;
          player.onGround = false;
          player.jumpsUsed = 1;
          playTone(880, 0.08, "square", 0.04);
        } else if (player.jumpsUsed < 2) {
          player.vy = -500;
          player.jumpsUsed = 2;
          spawnParticles(player.x + player.w * 0.5, player.y + player.h, "#ffd98d", 8);
          playTone(1020, 0.07, "square", 0.03);
        }
      }

      function checkAabb(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      function update(dt) {
        if (state.mode !== "playing") return;
        state.elapsed += dt;
        state.timeLeft = Math.max(0, 15 - state.elapsed);

        if (state.timeLeft <= 0) {
          endGame();
          return;
        }

        let speedMul = 1;
        if (state.elapsed > 10) {
          speedMul = 1.18 + clamp((state.elapsed - 10) / 5, 0, 1) * 0.37;
        } else if (state.elapsed > 5) {
          speedMul = 1 + clamp((state.elapsed - 5) / 5, 0, 1) * 0.18;
        }
        const buffMul = player.speedBuff > 0 ? 1.45 : 1;
        state.speed = 330 * speedMul * buffMul;
        state.distance += state.speed * dt;

        if (player.invincible > 0) player.invincible -= dt;
        if (player.speedBuff > 0) player.speedBuff -= dt;
        if (state.flashHit > 0) state.flashHit -= dt;

        player.vy += 1650 * dt;
        player.y += player.vy * dt;
        player.x += player.vx * dt;
        player.vx = 0;

        const scroll = state.speed * dt;
        world.totalLength -= scroll;
        for (const seg of world.segments) seg.x -= scroll;
        for (const hz of world.hazards) hz.x -= scroll;
        for (const enemy of world.enemies) {
          enemy.x -= scroll + enemy.vx * dt;
        }
        for (const item of world.pickups) {
          item.x -= scroll;
          item.bob += dt * 6;
        }

        while (world.totalLength < WIDTH + 320) addSegment();

        world.segments = world.segments.filter((s) => s.x + s.w > -120);
        world.hazards = world.hazards.filter((h) => h.x + h.w > -120);
        world.enemies = world.enemies.filter((e) => e.x + e.w > -100 && !e.dead);
        world.pickups = world.pickups.filter((p) => p.x + p.w > -100 && !p.dead);

        let landed = false;
        player.onGround = false;
        const playerFeetPrev = player.y + player.h - player.vy * dt;
        for (const seg of world.segments) {
          if (player.x + player.w > seg.x + 8 && player.x < seg.x + seg.w - 8) {
            const feet = player.y + player.h;
            if (feet >= seg.y && playerFeetPrev <= seg.y + 6 && player.vy >= 0) {
              player.y = seg.y - player.h;
              player.vy = 0;
              player.onGround = true;
              player.jumpsUsed = 0;
              landed = true;
            }
          }
        }

        if (!landed && player.y + player.h >= GROUND_Y) {
          player.y = GROUND_Y - player.h;
          player.vy = 0;
          player.onGround = true;
          player.jumpsUsed = 0;
        }

        for (const hz of world.hazards) {
          if (checkAabb(player, hz)) {
            hitPenalty();
          }
        }

        for (const enemy of world.enemies) {
          if (enemy.dead) continue;
          if (checkAabb(player, enemy)) {
            const stompHit = player.vy > 70 && player.y + player.h - 10 < enemy.y + 18;
            if (stompHit) {
              enemy.dead = true;
              player.vy = -360;
              state.stompCount += 1;
              state.combo += 1;
              state.maxCombo = Math.max(state.maxCombo, state.combo);
              addScore(150 * state.combo);
              spawnParticles(enemy.x + enemy.w * 0.5, enemy.y + enemy.h * 0.5, "#f8dd8b", 14);
              playTone(470 + state.combo * 20, 0.06, "triangle", 0.06);
              vibrate(18);
            } else if (player.invincible > 0) {
              enemy.dead = true;
              addScore(120);
              spawnParticles(enemy.x + enemy.w * 0.5, enemy.y + enemy.h * 0.5, "#fff5ab", 10);
            } else {
              hitPenalty();
            }
          }
        }

        for (const item of world.pickups) {
          if (item.dead) continue;
          const floatRect = { x: item.x, y: item.y + Math.sin(item.bob) * 6, w: item.w, h: item.h };
          if (checkAabb(player, floatRect)) {
            item.dead = true;
            if (item.type === "coin") {
              state.coins += 1;
              state.combo = Math.min(9, state.combo + 0.12);
              addScore(70 * Math.ceil(state.combo));
              playTone(1250, 0.05, "sine", 0.04);
              spawnParticles(item.x + 18, item.y + 18, "#f5cf63", 8);
            } else if (item.type === "fu") {
              player.invincible = 3.2;
              addScore(260);
              playTone(610, 0.12, "sawtooth", 0.03);
              spawnParticles(item.x + 18, item.y + 18, "#fff2a6", 16);
            } else if (item.type === "cake") {
              player.speedBuff = 3;
              addScore(220);
              playTone(760, 0.12, "triangle", 0.03);
              spawnParticles(item.x + 18, item.y + 18, "#ffc07a", 14);
            }
          }
        }

        if (player.onGround) {
          state.combo = Math.max(1, state.combo - dt * 0.9);
        }

        for (const p of state.particles) {
          p.life -= dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 850 * dt;
          p.alpha = Math.max(0, p.life / p.maxLife);
        }
        state.particles = state.particles.filter((p) => p.life > 0);

        addScore(dt * (18 + state.combo * 2.8));
        updateHud();
      }

      function hitPenalty() {
        addScore(-140);
        state.combo = 1;
        state.flashHit = 0.16;
        player.invincible = Math.max(player.invincible, 1);
        spawnParticles(player.x + player.w * 0.5, player.y + player.h * 0.4, "#ff7d6a", 10);
        playTone(170, 0.12, "sawtooth", 0.05);
        vibrate(26);
      }

      function addScore(delta) {
        state.score = Math.max(0, Math.round(state.score + delta));
      }

      function spawnParticles(x, y, color, count) {
        for (let i = 0; i < count; i += 1) {
          state.particles.push({
            x,
            y,
            vx: rand(-180, 180),
            vy: rand(-280, -60),
            life: rand(0.22, 0.44),
            maxLife: rand(0.22, 0.44),
            color,
            alpha: 1
          });
        }
      }

      function drawBackground() {
        const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        grad.addColorStop(0, "#13344d");
        grad.addColorStop(0.5, "#1a4f6c");
        grad.addColorStop(1, "#f7d7a5");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        ctx.globalAlpha = 0.15;
        for (let i = 0; i < 4; i += 1) {
          const y = 130 + i * 170;
          ctx.fillStyle = i % 2 === 0 ? "#fff4d4" : "#f9d273";
          ctx.beginPath();
          ctx.ellipse((state.distance * -0.05 + i * 155) % (WIDTH + 320) - 140, y, 180, 28, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        ctx.fillStyle = "#d14a3a";
        for (let i = 0; i < 8; i += 1) {
          const x = (i * 86 + (state.distance * -0.24) % 86) - 24;
          drawLantern(x, 94 + Math.sin((state.elapsed + i) * 2) * 4, 19);
        }
      }

      function drawLantern(x, y, size) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = "#f3c044";
        ctx.fillRect(size * 0.45, -22, size * 0.1, 14);
        ctx.beginPath();
        ctx.ellipse(size * 0.5, 8, size, size * 1.2, 0, 0, Math.PI * 2);
        ctx.fillStyle = "#cc2f37";
        ctx.fill();
        ctx.fillStyle = "#f5d479";
        ctx.fillRect(size * 0.2, 0, size * 0.6, 3);
        ctx.fillRect(size * 0.2, 12, size * 0.6, 3);
        ctx.fillStyle = "#f3c044";
        ctx.fillRect(size * 0.47, 22, size * 0.08, 16);
        ctx.restore();
      }

      function drawGround() {
        ctx.fillStyle = "#8c3a21";
        ctx.fillRect(0, GROUND_Y, WIDTH, HEIGHT - GROUND_Y);
        for (let i = 0; i < WIDTH; i += 44) {
          ctx.fillStyle = i % 88 === 0 ? "#be6038" : "#9a4628";
          ctx.fillRect(i, GROUND_Y + 8, 38, 12);
        }
      }

      function drawSegments() {
        for (const seg of world.segments) {
          ctx.fillStyle = "#cc2f37";
          roundRect(seg.x, seg.y, seg.w, seg.h, 8, true);
          ctx.fillStyle = "#f2cf7a";
          ctx.fillRect(seg.x + 5, seg.y + 5, seg.w - 10, 3);
          ctx.fillRect(seg.x + 5, seg.y + seg.h - 8, seg.w - 10, 3);
          ctx.fillStyle = "#fff2cb";
          ctx.font = "bold 12px Trebuchet MS, sans-serif";
          ctx.fillText("春", seg.x + 8, seg.y + 16);
        }
      }

      function drawHazards() {
        for (const hz of world.hazards) {
          ctx.fillStyle = "#1b1f28";
          roundRect(hz.x, GROUND_Y - 4, hz.w, 10, 4, true);
          for (let i = 0; i < hz.w; i += 14) {
            ctx.fillStyle = i % 28 === 0 ? "#f7ca4e" : "#db3e33";
            ctx.beginPath();
            ctx.moveTo(hz.x + i + 2, GROUND_Y + 6);
            ctx.lineTo(hz.x + i + 8, GROUND_Y + 30);
            ctx.lineTo(hz.x + i - 4, GROUND_Y + 30);
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      function drawPickups() {
        for (const item of world.pickups) {
          const y = item.y + Math.sin(item.bob) * 6;
          if (item.type === "coin") {
            ctx.fillStyle = "#f4c341";
            ctx.beginPath();
            ctx.arc(item.x + 18, y + 18, 16, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#88540f";
            ctx.font = "bold 18px Trebuchet MS, sans-serif";
            ctx.fillText("¥", item.x + 12, y + 24);
          } else if (item.type === "fu") {
            ctx.fillStyle = "#f4edc5";
            roundRect(item.x + 3, y + 3, 30, 30, 4, true);
            ctx.fillStyle = "#cb2a35";
            ctx.font = "bold 18px Trebuchet MS, sans-serif";
            ctx.fillText("福", item.x + 7, y + 24);
          } else {
            ctx.fillStyle = "#f2bc76";
            roundRect(item.x + 4, y + 7, 28, 22, 9, true);
            ctx.fillStyle = "#e18242";
            ctx.fillRect(item.x + 7, y + 15, 22, 4);
          }
        }
      }

      function drawEnemies() {
        for (const e of world.enemies) {
          ctx.save();
          ctx.translate(e.x, e.y);
          ctx.fillStyle = "#7a2f1f";
          roundRect(0, 8, e.w, e.h - 8, 8, true);
          ctx.fillStyle = "#e8b07d";
          roundRect(8, 0, e.w - 16, 18, 7, true);
          ctx.fillStyle = "#ffe5bf";
          ctx.fillRect(13, 14, 8, 6);
          ctx.fillRect(31, 14, 8, 6);
          ctx.fillStyle = "#2d1710";
          ctx.fillRect(16, 15, 3, 3);
          ctx.fillRect(34, 15, 3, 3);
          ctx.fillStyle = "#d34233";
          ctx.fillRect(20, 20, 12, 4);
          ctx.restore();
        }
      }

      function drawPlayer() {
        ctx.save();
        ctx.translate(player.x, player.y);

        if (state.flashHit > 0) {
          ctx.globalAlpha = 0.5 + Math.sin(state.elapsed * 52) * 0.5;
        }

        if (player.invincible > 0) {
          ctx.strokeStyle = "#fff5ab";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(player.w * 0.5, player.h * 0.45, 52 + Math.sin(state.elapsed * 18) * 2, 0, Math.PI * 2);
          ctx.stroke();
        }

        const bob = player.onGround ? Math.sin(state.elapsed * 17) * 1.4 : 0;
        const legStretch = player.onGround ? 0 : Math.min(8, Math.max(0, player.vy * 0.02));

        ctx.fillStyle = "#6f4028";
        ctx.beginPath();
        ctx.moveTo(12, 38 + bob);
        ctx.quadraticCurveTo(18, 20 + bob, 36, 18 + bob);
        ctx.quadraticCurveTo(60, 18 + bob, 68, 34 + bob);
        ctx.quadraticCurveTo(64, 56 + bob, 38, 60 + bob);
        ctx.quadraticCurveTo(16, 58 + bob, 12, 38 + bob);
        ctx.fill();

        ctx.fillStyle = "#845037";
        ctx.fillRect(24, 26 + bob, 24, 10);

        ctx.fillStyle = "#6f4028";
        ctx.beginPath();
        ctx.moveTo(48, 24 + bob);
        ctx.quadraticCurveTo(54, 10 + bob, 66, 11 + bob);
        ctx.quadraticCurveTo(75, 11 + bob, 74, 23 + bob);
        ctx.quadraticCurveTo(71, 34 + bob, 60, 34 + bob);
        ctx.quadraticCurveTo(52, 34 + bob, 48, 24 + bob);
        ctx.fill();

        ctx.fillStyle = "#e8bf95";
        ctx.beginPath();
        ctx.ellipse(69, 25 + bob, 10, 7, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#2d1a13";
        ctx.fillRect(69, 22 + bob, 2, 2);
        ctx.fillRect(73, 24 + bob, 2, 2);
        ctx.fillRect(61, 19 + bob, 3, 3);

        ctx.fillStyle = "#5a3121";
        ctx.beginPath();
        ctx.moveTo(60, 10 + bob);
        ctx.lineTo(63, 0 + bob);
        ctx.lineTo(67, 9 + bob);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(66, 10 + bob);
        ctx.lineTo(70, 1 + bob);
        ctx.lineTo(72, 11 + bob);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = "#4b281a";
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(13, 33 + bob);
        ctx.quadraticCurveTo(2, 23 + bob, 7, 14 + bob);
        ctx.stroke();

        ctx.fillStyle = "#c22831";
        roundRect(24, 12 + bob, 16, 14, 4, true);
        ctx.fillStyle = "#f7e6bf";
        ctx.font = "bold 11px Trebuchet MS, sans-serif";
        ctx.fillText("福", 27, 23 + bob);

        ctx.fillStyle = "#5e3321";
        roundRect(14, 56 + bob, 10, 20 + legStretch, 4, true);
        roundRect(28, 58 + bob, 10, 18 + legStretch, 4, true);
        roundRect(44, 58 + bob, 10, 18 + legStretch, 4, true);
        roundRect(58, 55 + bob, 10, 21 + legStretch, 4, true);

        ctx.fillStyle = "#3f2418";
        ctx.fillRect(14, 74 + bob + legStretch, 10, 4);
        ctx.fillRect(28, 74 + bob + legStretch, 10, 4);
        ctx.fillRect(44, 74 + bob + legStretch, 10, 4);
        ctx.fillRect(58, 74 + bob + legStretch, 10, 4);
        ctx.restore();
      }

      function drawParticles() {
        for (const p of state.particles) {
          ctx.globalAlpha = p.alpha;
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, 4, 4);
        }
        ctx.globalAlpha = 1;
      }

      function drawUiHints() {
        if (state.mode !== "playing") return;
        const pulse = 0.65 + Math.sin(state.elapsed * 6) * 0.2;
        ctx.globalAlpha = pulse;
        ctx.fillStyle = "#fff4cf";
        ctx.font = "600 16px Trebuchet MS, sans-serif";
        ctx.fillText("点击跳 · 连点二段跳", 142, HEIGHT - 34);
        ctx.globalAlpha = 1;
      }

      function render() {
        drawBackground();
        drawGround();
        drawHazards();
        drawSegments();
        drawPickups();
        drawEnemies();
        drawPlayer();
        drawParticles();
        drawUiHints();
      }

      function roundRect(x, y, w, h, r, fill) {
        const rr = Math.min(r, w * 0.5, h * 0.5);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
        if (fill) ctx.fill();
      }

      function updateHud() {
        timeText.textContent = state.timeLeft.toFixed(1) + "秒";
        comboText.textContent = "连击 x" + Math.max(1, Math.floor(state.combo));
        scoreText.textContent = state.score + " 分";
      }

      function getTitleByScore(score) {
        if (score >= 6800) return "春晚跑酷王";
        if (score >= 5400) return "年兽克星";
        if (score >= 4100) return "迎春快马";
        if (score >= 2800) return "元宝猎手";
        return "新年热身马";
      }

      function endGame() {
        state.mode = "result";
        const meter = Math.floor(state.distance / 10);
        const title = getTitleByScore(state.score);
        resultTitle.textContent = title;
        resultStats.innerHTML =
          "总分：" + state.score + " 分<br>" +
          "元宝：" + state.coins + " 个<br>" +
          "踩年兽：" + state.stompCount + " 只<br>" +
          "最高连击：x" + state.maxCombo + "<br>" +
          "跑动距离：" + meter + " 米";
        resultOverlay.classList.remove("hidden");
        playTone(520, 0.16, "triangle", 0.06);
        setTimeout(() => playTone(760, 0.2, "triangle", 0.05), 120);
      }

      let audioCtx = null;
      function ensureAudio() {
        try {
          if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (audioCtx.state === "suspended") {
            audioCtx.resume();
          }
          state.soundsReady = true;
        } catch (err) {
          state.soundsReady = false;
        }
      }

      function playTone(freq, dur, type, gainValue) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, now);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(gainValue, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + dur + 0.02);
      }

      function vibrate(ms) {
        if (navigator.vibrate) navigator.vibrate(ms);
      }

      function onPointerDown(ev) {
        ev.preventDefault();
        ensureAudio();

        if (state.mode === "ready") {
          startOverlay.classList.add("hidden");
          resetGame();
          return;
        }
        if (state.mode === "result") return;
        jump();
      }

      canvas.addEventListener("pointerdown", onPointerDown, { passive: false });
      window.addEventListener("touchstart", ensureAudio, { passive: true });

      startBtn.addEventListener("click", () => {
        ensureAudio();
        startOverlay.classList.add("hidden");
        resetGame();
      });

      retryBtn.addEventListener("click", () => {
        resultOverlay.classList.add("hidden");
        resetGame();
      });

      document.addEventListener("visibilitychange", () => {
        if (document.hidden && state.mode === "playing") {
          state.mode = "ready";
          startOverlay.classList.remove("hidden");
        }
      });

      let last = performance.now();
      function loop(now) {
        const dt = Math.min(0.033, (now - last) / 1000);
        last = now;
        update(dt);
        render();
        requestAnimationFrame(loop);
      }

      updateHud();
      render();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
